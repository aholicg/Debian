{"version":2,"sessionId":"57354b3e-3103-4bae-8ae7-bc7897834d59","initialFileContents":[["file:///home/trang/localnsv/mAIware/ai-client.js","8ebf55c"],["file:///home/trang/localnsv/mAIware---AI/predict_single.py","1bfc461"],["file:///home/trang/localnsv/mAIware/script.js","5d5b25f"],["file:///home/trang/localnsv/mAIware---AI/requirements.txt","c1e576c"]],"timeline":{"checkpoints":[{"checkpointId":"c737df9f-1fc7-4f2a-9f0f-f2d368cde54f","epoch":0,"label":"Initial State","description":"Starting point before any edits"},{"checkpointId":"175c8a8f-4915-4db1-9a0a-6aaca368a634","requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","epoch":1,"label":"Request request_3f8c43eb-e769-4b31-b18f-28aa1315741b"},{"checkpointId":"53ef8567-087a-479e-a430-781e85864c71","requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","undoStopId":"bb1fa7b9-b1b4-494e-8b5f-b4470d2f3fd6","epoch":2,"label":"Request request_3f8c43eb-e769-4b31-b18f-28aa1315741b - Stop bb1fa7b9-b1b4-494e-8b5f-b4470d2f3fd6"},{"checkpointId":"b18849ca-0a22-46cd-a5d1-62130f018e2d","requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","undoStopId":"c8f8685a-ed30-493c-89fd-a3f9cffd53eb","epoch":5,"label":"Request request_3f8c43eb-e769-4b31-b18f-28aa1315741b - Stop c8f8685a-ed30-493c-89fd-a3f9cffd53eb"},{"checkpointId":"5f63b1a8-c767-44ab-a321-9ecaa97e6f35","requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","undoStopId":"daf3da18-a0b7-47aa-b7c4-4e00759568da","epoch":8,"label":"Request request_3f8c43eb-e769-4b31-b18f-28aa1315741b - Stop daf3da18-a0b7-47aa-b7c4-4e00759568da"},{"checkpointId":"83289d90-90ae-4ca9-99df-6d17f7dad2fa","requestId":"request_5aebc088-3c41-437c-a27d-6a0403cfa541","epoch":10,"label":"Request request_5aebc088-3c41-437c-a27d-6a0403cfa541"},{"checkpointId":"a5556c83-5a00-4e39-b211-6b8e09d5b197","requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","epoch":11,"label":"Request request_cea1c3f5-681f-43b2-927b-2bd12d471bbb"},{"checkpointId":"08cdb94a-90a2-4333-b651-c24d71f2c320","requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","undoStopId":"9676e9fe-b641-4f57-9531-53d6b5df4a2a","epoch":12,"label":"Request request_cea1c3f5-681f-43b2-927b-2bd12d471bbb - Stop 9676e9fe-b641-4f57-9531-53d6b5df4a2a"},{"checkpointId":"e7476e39-24db-4739-82f5-1c47c88b8eec","requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","undoStopId":"d4f1e90a-e0fd-4f75-a611-7bbbbc8053dd","epoch":15,"label":"Request request_cea1c3f5-681f-43b2-927b-2bd12d471bbb - Stop d4f1e90a-e0fd-4f75-a611-7bbbbc8053dd"},{"checkpointId":"0a9173d1-bad1-4269-813a-5e8f25417f10","requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","undoStopId":"249330a2-a51c-48e8-98ca-d136ce6dc0c7","epoch":17,"label":"Request request_cea1c3f5-681f-43b2-927b-2bd12d471bbb - Stop 249330a2-a51c-48e8-98ca-d136ce6dc0c7"},{"checkpointId":"db8f073e-415c-41f1-acd3-30a5c294a214","requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","undoStopId":"12186818-5d4c-47c2-a267-68a3040917c9","epoch":19,"label":"Request request_cea1c3f5-681f-43b2-927b-2bd12d471bbb - Stop 12186818-5d4c-47c2-a267-68a3040917c9"},{"checkpointId":"d0e3236c-2b53-4732-b08b-c3b3913da7ee","requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","undoStopId":"fd4690ac-8182-41e5-a4d7-8dd1d47a2d79","epoch":22,"label":"Request request_cea1c3f5-681f-43b2-927b-2bd12d471bbb - Stop fd4690ac-8182-41e5-a4d7-8dd1d47a2d79"},{"checkpointId":"2dd46d36-7eba-4d17-a9b3-9cc836af6bd1","requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","undoStopId":"6710d6ea-1a20-4fd6-bc72-656fb9a1e7c9","epoch":25,"label":"Request request_cea1c3f5-681f-43b2-927b-2bd12d471bbb - Stop 6710d6ea-1a20-4fd6-bc72-656fb9a1e7c9"},{"checkpointId":"47b0bf3b-78b8-49f6-af48-c397c94941dd","requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","undoStopId":"19efde46-e631-4915-a835-29c22a2bc4d2","epoch":27,"label":"Request request_cea1c3f5-681f-43b2-927b-2bd12d471bbb - Stop 19efde46-e631-4915-a835-29c22a2bc4d2"}],"currentEpoch":30,"fileBaselines":[["file:///home/trang/localnsv/mAIware/ai-client.js::request_3f8c43eb-e769-4b31-b18f-28aa1315741b",{"uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware/ai-client.js","external":"file:///home/trang/localnsv/mAIware/ai-client.js","path":"/home/trang/localnsv/mAIware/ai-client.js","scheme":"file"},"requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","content":"const { spawn } = require('node:child_process');\nconst path = require('node:path');\nconst crypto = require('node:crypto');\n\nconst AI_MODEL_DIR = path.join(__dirname, '..', 'mAIware---AI');\nconst PYTHON_SCRIPT = path.join(AI_MODEL_DIR, 'predict_single.py');\n\n// Map datasrcs for vendor/signature info\nconst { VENDORS, SIGNATURES } = require('./datasrcs');\n\n/**\n * Call AI model to classify a PE file and get comprehensive analysis\n * @param {string} filePath - Absolute path to the PE file\n * @param {object} fileHashes - Pre-computed SHA256 and MD5 hashes\n * @returns {Promise<object>} - Classification result with all metadata\n */\nasync function classifyWithAI(filePath, fileHashes) {\n  return new Promise((resolve, reject) => {\n    const python = spawn('python3', [PYTHON_SCRIPT, filePath], {\n      cwd: AI_MODEL_DIR,\n      env: { ...process.env }\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    python.stdout.on('data', (data) => {\n      stdout += data.toString();\n    });\n\n    python.stderr.on('data', (data) => {\n      stderr += data.toString();\n    });\n\n    python.on('close', (code) => {\n      if (code !== 0) {\n        console.error('[AI] Python process error:', stderr);\n        resolve({\n          classification: 'Suspicious',\n          confidence_score: 0.5,\n          error: 'AI model execution failed',\n          fallback: true\n        });\n        return;\n      }\n\n      try {\n        const aiResult = JSON.parse(stdout.trim());\n        \n        if (aiResult.error) {\n          console.error('[AI] Model returned error:', aiResult.error);\n          resolve({\n            classification: 'Suspicious',\n            confidence_score: 0.5,\n            error: aiResult.error,\n            fallback: true\n          });\n          return;\n        }\n\n        // Build comprehensive scan result matching expected format\n        const scanResult = buildScanResult(filePath, fileHashes, aiResult);\n        resolve(scanResult);\n        \n      } catch (err) {\n        console.error('[AI] Failed to parse JSON:', err.message);\n        console.error('[AI] Stdout:', stdout);\n        resolve({\n          classification: 'Suspicious',\n          confidence_score: 0.5,\n          error: 'Invalid AI response format',\n          fallback: true\n        });\n      }\n    });\n\n    python.on('error', (err) => {\n      console.error('[AI] Failed to spawn Python:', err);\n      resolve({\n        classification: 'Suspicious',\n        confidence_score: 0.5,\n        error: 'Python not available',\n        fallback: true\n      });\n    });\n  });\n}\n\n/**\n * Build a complete scan result from AI prediction\n * @param {string} filePath - Original file path\n * @param {object} fileHashes - SHA256 and MD5\n * @param {object} aiResult - AI model output\n * @returns {object} - Complete scan result matching UI expectations\n */\nfunction buildScanResult(filePath, fileHashes, aiResult) {\n  const filename = path.basename(filePath);\n  \n  // Select appropriate vendor based on classification\n  let vendor = VENDORS[15]; // Default: \"mAIware AI Engine\"\n  if (aiResult.classification === 'Malware') {\n    vendor = VENDORS[6]; // Windows Defender (red icon)\n  } else if (aiResult.classification === 'Benign') {\n    vendor = VENDORS[2]; // Microsoft (verified)\n  }\n  \n  // Determine signature status\n  let signature = SIGNATURES[4]; // Default: Not Signed\n  if (aiResult.classification === 'Benign' && Math.random() > 0.5) {\n    signature = SIGNATURES[0]; // Microsoft Corporation (verified)\n  } else if (aiResult.classification === 'Suspicious') {\n    signature = SIGNATURES[4]; // Unknown/Not Signed\n  } else if (aiResult.classification === 'Malware') {\n    signature = SIGNATURES[3]; // Self-signed\n  }\n\n  const result = {\n    detected_filename: filename,\n    file_hashes: fileHashes || { sha256: '', md5: '' },\n    classification: aiResult.classification,\n    confidence_score: aiResult.confidence_score,\n    is_pe: true,\n    vendor: vendor,\n    key_findings: {\n      file_type: aiResult.file_type || 'PE Executable',\n      packer_detected: aiResult.packer_detected || 'Unknown',\n      signature: signature,\n      section_entropy: aiResult.section_entropy || [],\n      api_imports: aiResult.api_imports || [],\n      key_strings: aiResult.key_strings || []\n    }\n  };\n\n  // Add AI-specific voting data if available\n  if (aiResult.votes_benign !== undefined && aiResult.votes_malware !== undefined) {\n    result.ai_voting = {\n      benign: aiResult.votes_benign,\n      malware: aiResult.votes_malware,\n      total_models: aiResult.votes_benign + aiResult.votes_malware\n    };\n  }\n\n  // Add PE feature metadata if available\n  if (aiResult.pe_features) {\n    result.pe_metadata = {\n      file_size: aiResult.pe_features.file_size,\n      entropy_total: aiResult.pe_features.entropy_total,\n      number_of_sections: aiResult.pe_features.number_of_sections,\n      total_dlls: aiResult.pe_features.total_dlls,\n      total_resources: aiResult.pe_features.total_resources,\n      is_packed: aiResult.pe_features.is_packed\n    };\n  }\n\n  return result;\n}\n\nmodule.exports = { classifyWithAI };\n","epoch":3,"telemetryInfo":{}}],["file:///home/trang/localnsv/mAIware---AI/predict_single.py::request_3f8c43eb-e769-4b31-b18f-28aa1315741b",{"uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware---AI/predict_single.py","external":"file:///home/trang/localnsv/mAIware---AI/predict_single.py","path":"/home/trang/localnsv/mAIware---AI/predict_single.py","scheme":"file"},"requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","content":"#!/usr/bin/env python3\n\"\"\"Predict a single PE file and output comprehensive JSON with features.\"\"\"\nimport json\nimport sys\nfrom pathlib import Path\nimport pefile\n\nfrom ensemble_predict_dir import (\n    load_model_columns, extract_features, prepare_feature_matrix,\n    run_models, DEFAULT_MODELS_DIR, DEFAULT_MODEL_COLS, DEFAULT_MODELS\n)\nfrom ensemble_vote import run_majority_voting\nimport pe_to_features\n\n\ndef extract_pe_sections(file_path: Path) -> list:\n    \"\"\"Extract section names and entropy from PE file.\"\"\"\n    try:\n        pe = pefile.PE(str(file_path), fast_load=True)\n        sections = []\n        for section in pe.sections:\n            name = section.Name.decode('utf-8', errors='ignore').strip('\\x00')\n            data = section.get_data() or b''\n            section_entropy = pe_to_features.entropy(data)\n            sections.append({\n                'name': name,\n                'entropy': round(section_entropy, 2),\n                'size': len(data)\n            })\n        pe.close()\n        return sections\n    except Exception as e:\n        print(f\"Warning: Failed to extract sections: {e}\", file=sys.stderr)\n        return []\n\n\ndef extract_pe_imports(file_path: Path) -> list:\n    \"\"\"Extract imported DLL and function names.\"\"\"\n    try:\n        pe = pefile.PE(str(file_path), fast_load=True)\n        pe.parse_data_directories(directories=[\n            pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']\n        ])\n        \n        imports = []\n        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):\n            for entry in pe.DIRECTORY_ENTRY_IMPORT:\n                dll_name = entry.dll.decode('utf-8', errors='ignore')\n                for imp in entry.imports[:5]:  # Limit to first 5 per DLL\n                    if imp.name:\n                        func_name = imp.name.decode('utf-8', errors='ignore')\n                        imports.append(func_name)\n        pe.close()\n        return imports[:20]  # Limit total to 20\n    except Exception as e:\n        print(f\"Warning: Failed to extract imports: {e}\", file=sys.stderr)\n        return []\n\n\ndef extract_pe_strings(file_path: Path, max_strings: int = 10) -> list:\n    \"\"\"Extract interesting strings from PE file.\"\"\"\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n        \n        # Simple string extraction (ASCII printable, min length 4)\n        strings = []\n        current = []\n        \n        for byte in data:\n            if 32 <= byte <= 126:  # Printable ASCII\n                current.append(chr(byte))\n            else:\n                if len(current) >= 4:\n                    s = ''.join(current)\n                    # Filter interesting strings\n                    interesting_keywords = ['http', 'www', '.exe', '.dll', 'cmd', 'shell', \n                                          'download', 'install', 'registry', 'temp', 'system']\n                    if any(kw in s.lower() for kw in interesting_keywords):\n                        strings.append(s)\n                        if len(strings) >= max_strings:\n                            break\n                current = []\n        \n        return strings[:max_strings]\n    except Exception as e:\n        print(f\"Warning: Failed to extract strings: {e}\", file=sys.stderr)\n        return []\n\n\ndef get_pe_type(file_path: Path) -> str:\n    \"\"\"Determine PE type (PE32/PE32+).\"\"\"\n    try:\n        pe = pefile.PE(str(file_path), fast_load=True)\n        if pe.OPTIONAL_HEADER.Magic == 0x20b:\n            result = 'PE64 Executable (PE32+)'\n        elif pe.OPTIONAL_HEADER.Magic == 0x10b:\n            result = 'PE32 Executable'\n        else:\n            result = 'PE Executable'\n        \n        # Check if it's a DLL\n        if pe.FILE_HEADER.Characteristics & 0x2000:\n            result = result.replace('Executable', 'DLL')\n        \n        pe.close()\n        return result\n    except Exception:\n        return 'PE Executable'\n\n\ndef detect_packer(file_path: Path, sections: list) -> str:\n    \"\"\"Detect common packers based on section names and entropy.\"\"\"\n    try:\n        # Check for high entropy sections (packed indicator)\n        high_entropy_sections = [s for s in sections if s.get('entropy', 0) > 7.5]\n        \n        # Check for common packer section names\n        section_names = [s.get('name', '').upper() for s in sections]\n        \n        if 'UPX0' in section_names or 'UPX1' in section_names:\n            return 'UPX'\n        elif '.aspack' in [s.lower() for s in section_names]:\n            return 'ASPack'\n        elif '.petite' in [s.lower() for s in section_names]:\n            return 'Petite'\n        elif len(high_entropy_sections) >= 2:\n            return 'Possibly Packed (High Entropy)'\n        elif len(high_entropy_sections) == 1:\n            return 'Suspicious (Partial Packing)'\n        else:\n            return 'None Detected'\n    except Exception:\n        return 'Unknown'\n\n\ndef predict_single_file(file_path: Path) -> dict:\n    \"\"\"Predict a single file and return comprehensive result dict.\"\"\"\n    try:\n        model_cols = load_model_columns(DEFAULT_MODEL_COLS)\n        \n        # Extract features\n        features_df = extract_features([file_path], model_cols)\n        if features_df.empty:\n            return {\n                \"error\": \"Failed to extract features\",\n                \"classification\": \"Suspicious\",\n                \"confidence_score\": 0.5\n            }\n        \n        feature_matrix = prepare_feature_matrix(features_df, model_cols)\n        \n        # Run models\n        predictions_df = run_models(feature_matrix, DEFAULT_MODELS, DEFAULT_MODELS_DIR)\n        voting_df, _ = run_majority_voting(predictions_df, DEFAULT_MODELS)\n        \n        # Get ensemble result\n        row = voting_df.iloc[0]\n        ensemble_class = row.get('ensemble_class', 'suspicious')\n        ensemble_score = float(row.get('ensemble_score', 0.5))\n        \n        # Extract PE metadata\n        sections = extract_pe_sections(file_path)\n        imports = extract_pe_imports(file_path)\n        strings = extract_pe_strings(file_path)\n        file_type = get_pe_type(file_path)\n        packer = detect_packer(file_path, sections)\n        \n        # Get feature values for additional context\n        feature_row = features_df.iloc[0]\n        \n        result = {\n            \"classification\": ensemble_class.capitalize(),  # Benign/Suspicious/Malware\n            \"confidence_score\": round(ensemble_score, 2),\n            \"votes_benign\": int(row.get('votes_benign', 0)),\n            \"votes_malware\": int(row.get('votes_malware', 0)),\n            \"file_type\": file_type,\n            \"packer_detected\": packer,\n            \"section_entropy\": sections,\n            \"api_imports\": imports,\n            \"key_strings\": strings,\n            \"pe_features\": {\n                \"file_size\": int(feature_row.get('FileSize', 0)),\n                \"entropy_total\": round(float(feature_row.get('Entropy_Total', 0)), 2),\n                \"number_of_sections\": int(feature_row.get('NumberOfSections', 0)),\n                \"total_dlls\": int(feature_row.get('Total_DLLs', 0)),\n                \"total_resources\": int(feature_row.get('Total_Resources', 0)),\n                \"is_packed\": int(feature_row.get('Packed', 0)) == 1\n            }\n        }\n        \n        return result\n        \n    except Exception as e:\n        print(f\"Error during prediction: {e}\", file=sys.stderr)\n        import traceback\n        traceback.print_exc(file=sys.stderr)\n        return {\n            \"error\": str(e),\n            \"classification\": \"Suspicious\",\n            \"confidence_score\": 0.5\n        }\n\n\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print(json.dumps({\"error\": \"No file path provided\"}))\n        sys.exit(1)\n    \n    file_path = Path(sys.argv[1])\n    if not file_path.exists():\n        print(json.dumps({\"error\": \"File not found\"}))\n        sys.exit(1)\n    \n    result = predict_single_file(file_path)\n    print(json.dumps(result, indent=2))\n","epoch":6,"telemetryInfo":{}}],["file:///home/trang/localnsv/mAIware---AI/predict_single.py::request_cea1c3f5-681f-43b2-927b-2bd12d471bbb",{"uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware---AI/predict_single.py","external":"file:///home/trang/localnsv/mAIware---AI/predict_single.py","path":"/home/trang/localnsv/mAIware---AI/predict_single.py","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","content":"#!/usr/bin/env python3\n\"\"\"Predict a single PE file and output comprehensive JSON with features.\"\"\"\nimport json\nimport sys\nfrom pathlib import Path\nimport pefile\n\nfrom ensemble_predict_dir import (\n    load_model_columns, extract_features, prepare_feature_matrix,\n    run_models, DEFAULT_MODELS_DIR, DEFAULT_MODEL_COLS, DEFAULT_MODELS\n)\nfrom ensemble_vote import run_majority_voting\nimport pe_to_features\n\n\ndef extract_pe_sections(file_path: Path) -> list:\n    \"\"\"Extract section names and entropy from PE file.\"\"\"\n    try:\n        pe = pefile.PE(str(file_path), fast_load=True)\n        sections = []\n        for section in pe.sections:\n            name = section.Name.decode('utf-8', errors='ignore').strip('\\x00')\n            data = section.get_data() or b''\n            section_entropy = pe_to_features.entropy(data)\n            sections.append({\n                'name': name,\n                'entropy': round(section_entropy, 2),\n                'size': len(data)\n            })\n        pe.close()\n        return sections\n    except Exception as e:\n        print(f\"Warning: Failed to extract sections: {e}\", file=sys.stderr)\n        return []\n\n\ndef extract_pe_imports(file_path: Path) -> list:\n    \"\"\"Extract imported DLL and function names.\"\"\"\n    try:\n        pe = pefile.PE(str(file_path), fast_load=True)\n        pe.parse_data_directories(directories=[\n            pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']\n        ])\n        \n        imports = []\n        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):\n            for entry in pe.DIRECTORY_ENTRY_IMPORT:\n                dll_name = entry.dll.decode('utf-8', errors='ignore')\n                for imp in entry.imports[:5]:  # Limit to first 5 per DLL\n                    if imp.name:\n                        func_name = imp.name.decode('utf-8', errors='ignore')\n                        imports.append(func_name)\n        pe.close()\n        return imports[:20]  # Limit total to 20\n    except Exception as e:\n        print(f\"Warning: Failed to extract imports: {e}\", file=sys.stderr)\n        return []\n\n\ndef extract_pe_strings(file_path: Path, max_strings: int = 10) -> list:\n    \"\"\"Extract interesting strings from PE file.\"\"\"\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n        \n        # Simple string extraction (ASCII printable, min length 4)\n        strings = []\n        current = []\n        \n        for byte in data:\n            if 32 <= byte <= 126:  # Printable ASCII\n                current.append(chr(byte))\n            else:\n                if len(current) >= 4:\n                    s = ''.join(current)\n                    # Filter interesting strings\n                    interesting_keywords = ['http', 'www', '.exe', '.dll', 'cmd', 'shell', \n                                          'download', 'install', 'registry', 'temp', 'system']\n                    if any(kw in s.lower() for kw in interesting_keywords):\n                        strings.append(s)\n                        if len(strings) >= max_strings:\n                            break\n                current = []\n        \n        return strings[:max_strings]\n    except Exception as e:\n        print(f\"Warning: Failed to extract strings: {e}\", file=sys.stderr)\n        return []\n\n\ndef get_pe_type(file_path: Path) -> str:\n    \"\"\"Determine PE type (PE32/PE32+).\"\"\"\n    try:\n        pe = pefile.PE(str(file_path), fast_load=True)\n        if pe.OPTIONAL_HEADER.Magic == 0x20b:\n            result = 'PE64 Executable (PE32+)'\n        elif pe.OPTIONAL_HEADER.Magic == 0x10b:\n            result = 'PE32 Executable'\n        else:\n            result = 'PE Executable'\n        \n        # Check if it's a DLL\n        if pe.FILE_HEADER.Characteristics & 0x2000:\n            result = result.replace('Executable', 'DLL')\n        \n        pe.close()\n        return result\n    except Exception:\n        return 'PE Executable'\n\n\ndef detect_packer(file_path: Path, sections: list) -> str:\n    \"\"\"Detect common packers based on section names and entropy.\"\"\"\n    try:\n        # Check for high entropy sections (packed indicator)\n        high_entropy_sections = [s for s in sections if s.get('entropy', 0) > 7.5]\n        \n        # Check for common packer section names\n        section_names = [s.get('name', '').upper() for s in sections]\n        \n        if 'UPX0' in section_names or 'UPX1' in section_names:\n            return 'UPX'\n        elif '.aspack' in [s.lower() for s in section_names]:\n            return 'ASPack'\n        elif '.petite' in [s.lower() for s in section_names]:\n            return 'Petite'\n        elif len(high_entropy_sections) >= 2:\n            return 'Possibly Packed (High Entropy)'\n        elif len(high_entropy_sections) == 1:\n            return 'Suspicious (Partial Packing)'\n        else:\n            return 'None Detected'\n    except Exception:\n        return 'Unknown'\n\n\ndef predict_single_file(file_path: Path) -> dict:\n    \"\"\"Predict a single file and return comprehensive result dict.\"\"\"\n    try:\n        model_cols = load_model_columns(DEFAULT_MODEL_COLS)\n        \n        # Extract features\n        features_df = extract_features([file_path], model_cols)\n        if features_df.empty:\n            return {\n                \"error\": \"Failed to extract features\",\n                \"classification\": \"Suspicious\",\n                \"confidence_score\": 0.5\n            }\n        \n        feature_matrix = prepare_feature_matrix(features_df, model_cols)\n        \n        # Run models\n        predictions_df = run_models(feature_matrix, DEFAULT_MODELS, DEFAULT_MODELS_DIR)\n        voting_df, _ = run_majority_voting(predictions_df, DEFAULT_MODELS)\n        \n        # Get ensemble result\n        row = voting_df.iloc[0]\n        ensemble_class = row.get('ensemble_class', 'suspicious')\n        ensemble_score = float(row.get('ensemble_score', 0.5))\n        \n        # Extract PE metadata\n        sections = extract_pe_sections(file_path)\n        imports = extract_pe_imports(file_path)\n        strings = extract_pe_strings(file_path)\n        file_type = get_pe_type(file_path)\n        packer = detect_packer(file_path, sections)\n        \n        # Get feature values for additional context\n        feature_row = features_df.iloc[0]\n        \n        result = {\n            \"classification\": ensemble_class.capitalize(),  # Benign/Suspicious/Malware\n            \"confidence_score\": round(ensemble_score, 2),\n            \"votes_benign\": int(row.get('votes_benign', 0)),\n            \"votes_malware\": int(row.get('votes_malware', 0)),\n            \"ensemble_label\": int(row.get('ensemble_label', 0)),  # 0=benign, 1=malware\n            \"ensemble_score\": round(ensemble_score, 2),\n            \"ensemble_class\": ensemble_class,  # benign/suspicious/malware\n            \"ensemble_class_id\": int(row.get('ensemble_class_id', 1)),  # 0/1/2\n            \"file_type\": file_type,\n            \"packer_detected\": packer,\n            \"section_entropy\": sections,\n            \"api_imports\": imports,\n            \"key_strings\": strings,\n            \"pe_features\": {\n                \"file_size\": int(feature_row.get('FileSize', 0)),\n                \"entropy_total\": round(float(feature_row.get('Entropy_Total', 0)), 2),\n                \"number_of_sections\": int(feature_row.get('NumberOfSections', 0)),\n                \"total_dlls\": int(feature_row.get('Total_DLLs', 0)),\n                \"total_resources\": int(feature_row.get('Total_Resources', 0)),\n                \"is_packed\": int(feature_row.get('Packed', 0)) == 1\n            }\n        }\n        \n        return result\n        \n    except Exception as e:\n        print(f\"Error during prediction: {e}\", file=sys.stderr)\n        import traceback\n        traceback.print_exc(file=sys.stderr)\n        return {\n            \"error\": str(e),\n            \"classification\": \"Suspicious\",\n            \"confidence_score\": 0.5\n        }\n\n\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print(json.dumps({\"error\": \"No file path provided\"}))\n        sys.exit(1)\n    \n    file_path = Path(sys.argv[1])\n    if not file_path.exists():\n        print(json.dumps({\"error\": \"File not found\"}))\n        sys.exit(1)\n    \n    result = predict_single_file(file_path)\n    print(json.dumps(result, indent=2))\n","epoch":13,"telemetryInfo":{}}],["file:///home/trang/localnsv/mAIware/ai-client.js::request_cea1c3f5-681f-43b2-927b-2bd12d471bbb",{"uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware/ai-client.js","external":"file:///home/trang/localnsv/mAIware/ai-client.js","path":"/home/trang/localnsv/mAIware/ai-client.js","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","content":"const { spawn } = require('node:child_process');\nconst path = require('node:path');\nconst crypto = require('node:crypto');\n\nconst AI_MODEL_DIR = path.join(__dirname, '..', 'mAIware---AI');\nconst PYTHON_SCRIPT = path.join(AI_MODEL_DIR, 'predict_single.py');\n\n// Map datasrcs for vendor/signature info\nconst { VENDORS, SIGNATURES } = require('./datasrcs');\n\n/**\n * Call AI model to classify a PE file and get comprehensive analysis\n * @param {string} filePath - Absolute path to the PE file\n * @param {object} fileHashes - Pre-computed SHA256 and MD5 hashes\n * @returns {Promise<object>} - Classification result with all metadata\n */\nasync function classifyWithAI(filePath, fileHashes) {\n  return new Promise((resolve, reject) => {\n    const python = spawn('python3', [PYTHON_SCRIPT, filePath], {\n      cwd: AI_MODEL_DIR,\n      env: { ...process.env }\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    python.stdout.on('data', (data) => {\n      stdout += data.toString();\n    });\n\n    python.stderr.on('data', (data) => {\n      stderr += data.toString();\n    });\n\n    python.on('close', (code) => {\n      if (code !== 0) {\n        console.error('[AI] Python process error:', stderr);\n        resolve({\n          classification: 'Suspicious',\n          confidence_score: 0.5,\n          error: 'AI model execution failed',\n          fallback: true\n        });\n        return;\n      }\n\n      try {\n        const aiResult = JSON.parse(stdout.trim());\n        \n        if (aiResult.error) {\n          console.error('[AI] Model returned error:', aiResult.error);\n          resolve({\n            classification: 'Suspicious',\n            confidence_score: 0.5,\n            error: aiResult.error,\n            fallback: true\n          });\n          return;\n        }\n\n        // Build comprehensive scan result matching expected format\n        const scanResult = buildScanResult(filePath, fileHashes, aiResult);\n        resolve(scanResult);\n        \n      } catch (err) {\n        console.error('[AI] Failed to parse JSON:', err.message);\n        console.error('[AI] Stdout:', stdout);\n        resolve({\n          classification: 'Suspicious',\n          confidence_score: 0.5,\n          error: 'Invalid AI response format',\n          fallback: true\n        });\n      }\n    });\n\n    python.on('error', (err) => {\n      console.error('[AI] Failed to spawn Python:', err);\n      resolve({\n        classification: 'Suspicious',\n        confidence_score: 0.5,\n        error: 'Python not available',\n        fallback: true\n      });\n    });\n  });\n}\n\n/**\n * Build a complete scan result from AI prediction\n * @param {string} filePath - Original file path\n * @param {object} fileHashes - SHA256 and MD5\n * @param {object} aiResult - AI model output\n * @returns {object} - Complete scan result matching UI expectations\n */\nfunction buildScanResult(filePath, fileHashes, aiResult) {\n  const filename = path.basename(filePath);\n  \n  // Select appropriate vendor based on classification\n  let vendor = VENDORS[15]; // Default: \"mAIware AI Engine\"\n  if (aiResult.classification === 'Malware') {\n    vendor = VENDORS[6]; // Windows Defender (red icon)\n  } else if (aiResult.classification === 'Benign') {\n    vendor = VENDORS[2]; // Microsoft (verified)\n  }\n  \n  // Determine signature status\n  let signature = SIGNATURES[4]; // Default: Not Signed\n  if (aiResult.classification === 'Benign' && Math.random() > 0.5) {\n    signature = SIGNATURES[0]; // Microsoft Corporation (verified)\n  } else if (aiResult.classification === 'Suspicious') {\n    signature = SIGNATURES[4]; // Unknown/Not Signed\n  } else if (aiResult.classification === 'Malware') {\n    signature = SIGNATURES[3]; // Self-signed\n  }\n\n  const result = {\n    detected_filename: filename,\n    file_hashes: fileHashes || { sha256: '', md5: '' },\n    classification: aiResult.classification,\n    confidence_score: aiResult.confidence_score,\n    is_pe: true,\n    vendor: vendor,\n    key_findings: {\n      file_type: aiResult.file_type || 'PE Executable',\n      packer_detected: aiResult.packer_detected || 'Unknown',\n      signature: signature,\n      section_entropy: aiResult.section_entropy || [],\n      api_imports: aiResult.api_imports || [],\n      key_strings: aiResult.key_strings || []\n    }\n  };\n\n  // Add AI-specific voting data (NEW from ensemble models)\n  if (aiResult.votes_benign !== undefined && aiResult.votes_malware !== undefined) {\n    result.votes_benign = aiResult.votes_benign;\n    result.votes_malware = aiResult.votes_malware;\n    result.ai_voting = {\n      benign: aiResult.votes_benign,\n      malware: aiResult.votes_malware,\n      total_models: aiResult.votes_benign + aiResult.votes_malware\n    };\n  }\n\n  // Add ensemble-specific fields (NEW from AI model CSV output)\n  if (aiResult.ensemble_label !== undefined) {\n    result.ensemble_label = aiResult.ensemble_label;\n  }\n  if (aiResult.ensemble_score !== undefined) {\n    result.ensemble_score = aiResult.ensemble_score;\n  }\n  if (aiResult.ensemble_class !== undefined) {\n    result.ensemble_class = aiResult.ensemble_class;\n  }\n  if (aiResult.ensemble_class_id !== undefined) {\n    result.ensemble_class_id = aiResult.ensemble_class_id;\n  }\n\n  // Add PE feature metadata (NEW from AI model)\n  if (aiResult.pe_features) {\n    result.pe_metadata = {\n      file_size: aiResult.pe_features.file_size,\n      entropy_total: aiResult.pe_features.entropy_total,\n      number_of_sections: aiResult.pe_features.number_of_sections,\n      total_dlls: aiResult.pe_features.total_dlls,\n      total_resources: aiResult.pe_features.total_resources,\n      is_packed: aiResult.pe_features.is_packed\n    };\n  }\n\n  return result;\n}\n\nmodule.exports = { classifyWithAI };\n","epoch":20,"telemetryInfo":{}}],["file:///home/trang/localnsv/mAIware/script.js::request_cea1c3f5-681f-43b2-927b-2bd12d471bbb",{"uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware/script.js","external":"file:///home/trang/localnsv/mAIware/script.js","path":"/home/trang/localnsv/mAIware/script.js","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","content":"// --- MOCK DISASSEMBLY DATA ---\n// (We keep this for now, as requested)\nconst mockDisassemblyBenign = [\n    `<span class=\"addr\">0x401000</span> <span class=\"op\">PUSH</span> <span class=\"args\">ebp</span> <span class=\"comment\">; setup stack frame</span>`,\n    `<span class=\"addr\">0x401001</span> <span class=\"op\">MOV</span> <span class=\"args\">ebp, esp</span>`,\n    `<span class=\"addr\">0x401003</span> <span class=\"op\">SUB</span> <span class=\"args\">esp, 48h</span>`,\n    `<span class=\"addr\">0x40100C</span> <span class=\"op\">CALL</span> <span class=\"args\">0x4012A0</span> <span class=\"comment\">; initialize_string</span>`,\n    `<span class=\"addr\">0x401015</span> <span class=\"op\">CALL</span> <span class=\"args\">0x4013F0</span> <span class=\"comment\">; get_user_input</span>`,\n    `<span class=\"addr\">0x40101E</span> <span class=\"op\">CALL</span> <span class=\"args\">0x4015D0</span> <span class=\"comment\">; print_output</span>`,\n    `<span class=\"addr\">0x401028</span> <span class=\"op\">RETN</span>`,\n    `<span class=\"addr\">...</span>`,\n];\nconst mockDisassemblySuspicious = [\n    `<span class=\"addr\">0x401000</span> <span class=\"op\">PUSH</span> <span class=\"args\">ebp</span>`,\n    `<span class=\"addr\">0x401003</span> <span class=\"op\">SUB</span> <span class=\"args\">esp, 80h</span>`,\n    `<span class=\"addr\">0x40100D</span> <span class=\"op\">CALL</span> <span class=\"args\">0x4012A0</span> <span class=\"comment\">; read_file_to_buffer</span>`,\n    `<span class=\"addr\">0x40101B</span> <span class=\"op\">REP</span> <span class=\"op\">MOVSB</span> <span class=\"comment\">; unsafe buffer write</span>`,\n    `<span class=\"addr\">0x401020</span> <span class=\"op\">JGE</span> <span class=\"args\">0x401030</span> <span class=\"comment\">; jump if overflow</span>`,\n    `<span class=\"addr\">0x401028</span> <span class=\"op\">RETN</span>`,\n    `<span class=\"addr\">...</span>`,\n];\nconst mockDisassemblyMalware = [\n    `<span class=\"addr\">0x401000</span> <span class=\"op\">PUSH</span> <span class=\"args\">ebp</span> <span class=\"comment\">; setup stack frame</span>`,\n    `<span class=\"addr\">0x40100B</span> <span class=\"op\">CALL</span> <span class=\"args\">0x4011B0</span> <span class=\"comment\">; kernel32.LoadLibraryA</span>`,\n    `<span class=\"addr\">0x401013</span> <span class=\"op\">PUSH</span> <span class=\"string\">\"CreateRemoteThread\"</span>`,\n    `<span class=\"addr\">0x401019</span> <span class=\"op\">CALL</span> <span class=\"args\">0x4011C0</span> <span class=\"comment\">; kernel32.GetProcAddress</span>`,\n    `<span class=\"addr\">0x401028</span> <span class=\"op\">CALL</span> <span class=\"args\">0x4012F0</span> <span class=\"comment\">; decrypt_payload</span>`,\n    `<span class=\"addr\">0x401034</span> <span class=\"op\">CALL</span> <span class=\"args\">[ebp-24h]</span> <span class=\"comment\">; call CreateRemoteThread</span>`,\n    `<span class=\"addr\">0x401037</span> <span class=\"op\">JMP</span> <span class=\"args\">0x40102D</span> <span class=\"comment\">; loop?</span>`,\n    `<span class=\"addr\">...</span>`,\n];\n\n// --- REMOVED MOCK GRAPH DATA ---\n// const mockGraphSafe = ... (DELETED)\n// const mockGraphSuspicious = ... (DELETED)\n// const mockGraphMalware = ... (DELETED)\n\n// --- NAVIGATION STATE ---\nlet scanHistory = [];\nlet currentHistoryIndex = -1;\n\n// --- ELEMENT REFERENCES ---\nconst initialState = document.getElementById('initial-state');\nconst analyzingState = document.getElementById('analyzing-state');\nconst resultState = document.getElementById('result-state');\n\nconst analyzingFilename = document.getElementById('analyzing-filename');\nconst resultIcon = document.getElementById('result-icon');\nconst resultText = document.getElementById('result-text');\nconst resultFilename = document.getElementById('result-filename');\nconst resultDetails = document.getElementById('result-details');\nconst nonPeResultWrapper = document.getElementById('non-pe-result');\nconst nonPeFilename = document.getElementById('non-pe-filename');\nconst nonPeHashSha256 = document.getElementById('non-pe-hash-sha256');\nconst nonPeHashMd5 = document.getElementById('non-pe-hash-md5');\nconst manualScanBtn = document.getElementById('manual-scan-btn');\nconst manualScanError = document.getElementById('manual-scan-error');\n\nconst bodyEl = document.body;\nlet animationWrapper = null;\n\nconst disassemblyWrapper = document.getElementById('disassembly-wrapper');\nconst disassemblyCodeEl = document.getElementById('disassembly-code');\nconst disassemblyFilenameEl = document.getElementById('disassembly-filename');\n\n// Analysis Details elements\nconst analysisDetailsWrapper = document.getElementById('analysis-details-wrapper');\nconst progressBarFill = document.getElementById('progress-bar-fill');\nconst scorePercentage = document.getElementById('score-percentage');\nconst detailsReasoning = document.getElementById('details-reasoning'); // We'll reuse this\nconst detailsHashSha256 = document.getElementById('details-hash-sha256');\nconst detailsHashMd5 = document.getElementById('details-hash-md5');\nconst detailsSystemIp = document.getElementById('details-system-ip');\nconst detailsRecommendation = document.getElementById('details-recommendation');\nconst detailsVendor = document.getElementById('details-vendor');\nconst detailsSignature = document.getElementById('details-signature');\nconst fileInternalsWrapper = document.getElementById('file-internals-wrapper');\nconst entropyBarsContainer = document.getElementById('entropy-bars-container');\nconst keyStringsContainer = document.getElementById('key-strings-container');\n\n// AI Voting elements\nconst aiVotingSection = document.getElementById('ai-voting-section');\nconst voteBarBenign = document.getElementById('vote-bar-benign');\nconst voteBarMalware = document.getElementById('vote-bar-malware');\nconst voteCountBenign = document.getElementById('vote-count-benign');\nconst voteCountMalware = document.getElementById('vote-count-malware');\n\n// PE Metadata elements\nconst peMetadataSection = document.getElementById('pe-metadata-section');\nconst peFileSize = document.getElementById('pe-file-size');\nconst peEntropyTotal = document.getElementById('pe-entropy-total');\nconst peSectionsCount = document.getElementById('pe-sections-count');\nconst peDllsCount = document.getElementById('pe-dlls-count');\nconst peResourcesCount = document.getElementById('pe-resources-count');\nconst peIsPacked = document.getElementById('pe-is-packed');\n\n// History Panel elements\nconst historyBtn = document.getElementById('history-btn');\nconst historyPanel = document.getElementById('history-panel');\nconst historyCloseBtn = document.getElementById('history-close-btn');\nconst historyOverlay = document.getElementById('history-overlay');\nconst historyListEl = document.querySelector('.history-list');\n\n// Home button element\nconst homeBtn = document.getElementById('home-btn');\n\n// Scroll Zone elements\nconst scrollZoneTop = document.getElementById('scroll-zone-top');\nconst scrollZoneBottom = document.getElementById('scroll-zone-bottom');\n\n// Graph Panel elements\nconst graphWrapper = document.getElementById('graph-wrapper');\nconst callGraphEl = document.getElementById('call-graph');\n\n// Stats elements\nconst statsWrapper = document.getElementById('stats-wrapper');\n\n\n// --- STATE ---\nlet disassemblyInterval = null;\nlet scrollInterval = null; // For auto-scrolling\nlet currentGraphLines = []; // Renamed from currentLines to avoid conflict\nlet currentFileMetadata = null;\nlet lastScanResult = null;\n\nfunction resolveScanStartedFilename(payload) {\n  if (typeof payload === 'string') {\n    return payload;\n  }\n\n  if (payload && typeof payload === 'object') {\n    if (typeof payload.filename === 'string' && payload.filename.length > 0) {\n      return payload.filename;\n    }\n\n    if (typeof payload.fullPath === 'string') {\n      const pathSegments = payload.fullPath.split(/[\\\\/]/);\n      return pathSegments[pathSegments.length - 1] || payload.fullPath;\n    }\n  }\n\n  return 'Unknown file';\n}\n\nfunction showManualScanError(message = '') {\n  if (!manualScanError) {\n    return;\n  }\n\n  manualScanError.textContent = message;\n}\n\nif (manualScanBtn) {\n  manualScanBtn.addEventListener('click', async (event) => {\n    event.preventDefault();\n    showManualScanError('');\n    manualScanBtn.disabled = true;\n\n    try {\n      const selection = await window.electronAPI.pickManualScanFile();\n      if (!selection || selection.canceled || !selection.filePath) {\n        return;\n      }\n\n      const response = await window.electronAPI.scanManualFile(selection.filePath);\n      if (!response || !response.ok) {\n        throw new Error(response && response.error ? response.error : 'Unable to start scan.');\n      }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Failed to start manual scan.';\n      showManualScanError(message);\n    } finally {\n      manualScanBtn.disabled = false;\n    }\n  });\n}\n\n// 1. Listen for the 'scan-started' message from the backend\nwindow.electronAPI.onScanStarted((payload) => {\n  const filename = resolveScanStartedFilename(payload);\n  console.log(`UI: Received scan-started for ${filename}`);\n\n    showManualScanError('');\n\n    // If user is viewing a result, don't auto-switch to analyzing.\n    if (bodyEl.classList.contains('is-showing-result') || bodyEl.classList.contains('is-non-pe')) {\n        console.log('UI: Result is being viewed; deferring analyzing UI switch');\n        return;\n    }\n\n  // 1. Set UI to \"Analyzing\" state\n  initialState.classList.remove('active'); //\n  analyzingState.classList.add('active'); //\n  analyzingFilename.textContent = filename; //\n  disassemblyFilenameEl.textContent = filename; //\n\n  currentFileMetadata = { filename, isPe: true };\n  lastScanResult = null;\n  nonPeResultWrapper.classList.remove('active');\n  bodyEl.classList.remove('is-non-pe');\n\n  // 2. Update body class to show disassembly\n  bodyEl.classList.remove('is-showing-result'); //\n  bodyEl.classList.add('is-analyzing'); //\n  removeAnimationClasses(); //\n  \n  // 3. Populate disassembly with a \"suspicious\" default and start animation\n  // (We don't know the result yet, so we pick one)\n  populateDisassembly(mockDisassemblySuspicious); //\n  startDisassemblyAnimation(); //\n\n  // 4. Clear old results\n  clearResultData();\n});\n\n// 2. Listen for the 'scan-result' message\nwindow.electronAPI.onScanResult((scanResult) => {\n  console.log(\"UI: Received scan-result:\", scanResult);\n\n  clearInterval(disassemblyInterval); //\n  disassemblyInterval = null; //\n\n  // Add to history\n  scanHistory.push(scanResult);\n  currentHistoryIndex = scanHistory.length - 1;\n\n    // If a result is already being viewed, do not auto-advance UI.\n    if (bodyEl.classList.contains('is-showing-result') || bodyEl.classList.contains('is-non-pe')) {\n        updateNavigationButtons();\n        return;\n    }\n\n    bodyEl.classList.remove('is-analyzing'); //\n    bodyEl.classList.add('is-showing-result'); //\n\n    analyzingState.classList.remove('active'); //\n    resultState.classList.add('active'); //\n\n    lastScanResult = scanResult;\n    renderScanResult();\n    updateNavigationButtons();\n});\n\nwindow.electronAPI.onScanFileMetadata((metadata) => {\n  if (!metadata || typeof metadata !== 'object') {\n    return;\n  }\n\n  currentFileMetadata = metadata;\n\n  if (lastScanResult && metadata.filename === lastScanResult.detected_filename) {\n    renderScanResult();\n  }\n});\n\nfunction renderScanResult() {\n  if (!lastScanResult) {\n    return;\n  }\n\n  const metadataMatches = currentFileMetadata && currentFileMetadata.filename === lastScanResult.detected_filename;\n  const isNonPe = metadataMatches && currentFileMetadata.isPe === false;\n\n  if (isNonPe) {\n    renderNonPeResult(lastScanResult);\n    return;\n  }\n\n  renderPeResult(lastScanResult);\n}\n\nfunction ensureAnimationWrapper() {\n  if (animationWrapper) {\n    return;\n  }\n\n  animationWrapper = document.createElement('div');\n  animationWrapper.className = 'animation-swarm';\n  for (let i = 0; i < 10; i++) {\n    const particle = document.createElement('span');\n    animationWrapper.appendChild(particle);\n  }\n  bodyEl.prepend(animationWrapper);\n}\n\nfunction renderPeResult(scanResult) {\n  removeAnimationClasses();\n  bodyEl.classList.remove('is-non-pe');\n  nonPeResultWrapper.classList.remove('active');\n\n  let resultIconClass = 'fas fa-check-circle'; //\n  let resultMockDisassembly = mockDisassemblyBenign; //\n  let resultBodyClass = 'result-safe-active'; //\n  let resultScannerClass = 'result-safe'; //\n  let resultProgressClass = 'progress-bar-green'; //\n  let resultScoreClass = 'score-green'; //\n  let recommendation = 'You can safely run this file.'; //\n\n  if (scanResult.classification.includes('Malware')) {\n    resultIconClass = 'fas fa-bug';\n    resultMockDisassembly = mockDisassemblyMalware;\n    resultBodyClass = 'result-malware-active'; //\n    resultScannerClass = 'result-malware'; //\n    resultProgressClass = 'progress-bar-red'; //\n    resultScoreClass = 'score-red'; //\n    recommendation = 'DO NOT OPEN. Quarantine this file immediately.'; //\n  } else if (scanResult.classification.includes('Suspicious')) {\n    resultIconClass = 'fas fa-exclamation-triangle'; //\n    resultMockDisassembly = mockDisassemblySuspicious; //\n    resultBodyClass = 'result-suspicious-active'; //\n    resultScannerClass = 'result-suspicious'; //\n    resultProgressClass = 'progress-bar-yellow'; //\n    resultScoreClass = 'score-yellow'; //\n    recommendation = 'Be cautious. Only run if you trust the source.'; //\n  }\n\n  ensureAnimationWrapper();\n  bodyEl.classList.add(resultBodyClass); //\n\n  resultState.className = `scanner-state active ${resultScannerClass}`; //\n  resultIcon.className = `result-icon ${resultIconClass}`; //\n  resultText.textContent = scanResult.classification; //\n\n  let detailsText = `Scanned ${scanResult.detected_filename}.`;\n  if (scanResult.malware_family) {\n    detailsText = `Family: ${scanResult.malware_family}`;\n  }\n  resultDetails.textContent = detailsText;\n  resultFilename.textContent = scanResult.detected_filename; //\n\n  progressBarFill.className = 'progress-bar-fill'; //\n  scorePercentage.className = 'score-percentage'; //\n  progressBarFill.classList.add(resultProgressClass); //\n  const rawConfidence = Number(scanResult.confidence_score);\n  const confidenceValue = Number.isFinite(rawConfidence) ? rawConfidence * 100 : 0;\n  progressBarFill.style.width = `${confidenceValue}%`; //\n  scorePercentage.textContent = `${Math.round(confidenceValue)}%`; //\n  scorePercentage.classList.add(resultScoreClass); //\n\n  detailsReasoning.textContent = `Filetype: ${scanResult.key_findings.file_type}. Packer: ${scanResult.key_findings.packer_detected}.`; //\n  const hashData = scanResult.file_hashes || {};\n  detailsHashSha256.textContent = hashData.sha256 || 'Not available'; //\n  detailsHashMd5.textContent = hashData.md5 || 'Not available'; //\n  updateSystemIpDisplay();\n  detailsRecommendation.textContent = recommendation;\n\n  populateVendor(scanResult.vendor); //\n  populateSignature(scanResult.key_findings.signature); //\n  populateEntropyBars(scanResult.key_findings.section_entropy || []); //\n  populateKeyStrings(scanResult.key_findings.key_strings || [], scanResult.classification); //\n\n  populateDisassembly(resultMockDisassembly); //\n\n  const apiList = scanResult.key_findings.api_imports || [];\n  const graphData = generateGraphData(apiList, scanResult.classification);\n  drawCallGraph(graphData);\n  \n  // Populate AI-specific sections if data is available\n  populateAIVoting(scanResult.ai_voting);\n  populatePeMetadata(scanResult.pe_metadata);\n\n  // Generate QR for PE report\n  generatePeQr(scanResult);\n}\n\nfunction renderNonPeResult(scanResult) {\n  removeAnimationClasses();\n  bodyEl.classList.add('is-non-pe');\n  resultState.className = 'scanner-state active';\n  resultIcon.className = 'result-icon fas fa-file';\n  resultText.textContent = '';\n  resultDetails.textContent = '';\n  resultFilename.textContent = '';\n\n  const hashData = scanResult.file_hashes || {};\n  nonPeFilename.textContent = scanResult.detected_filename || '';\n  nonPeHashSha256.textContent = hashData.sha256 || 'Not available';\n  nonPeHashMd5.textContent = hashData.md5 || 'Not available';\n\n  detailsHashSha256.textContent = hashData.sha256 || 'Not available';\n  detailsHashMd5.textContent = hashData.md5 || 'Not available';\n\n  nonPeResultWrapper.classList.add('active');\n\n  callGraphEl.innerHTML = '';\n  currentGraphLines.forEach(line => line.remove());\n  currentGraphLines = [];\n  entropyBarsContainer.innerHTML = '';\n  keyStringsContainer.innerHTML = '';\n\n    // Hide QR for non-PE\n    clearQr();\n}\n\n/**\n * Clears all dynamic result data to prepare for the next scan.\n */\nfunction clearResultData() {\n    // Clear scanner panel\n    resultText.textContent = '';\n    resultDetails.textContent = '';\n    resultFilename.textContent = '';\n    nonPeResultWrapper.classList.remove('active');\n    nonPeFilename.textContent = '';\n    nonPeHashSha256.textContent = '...';\n    nonPeHashMd5.textContent = '...';\n    bodyEl.classList.remove('is-non-pe');\n\n    // Clear analysis panel\n    progressBarFill.style.width = `0%`;\n    scorePercentage.textContent = `0%`;\n    detailsReasoning.textContent = '...';\n    detailsHashSha256.textContent = '...';\n    detailsHashMd5.textContent = '...';\n    if (detailsSystemIp) {\n        detailsSystemIp.textContent = 'Detecting...';\n    }\n    detailsRecommendation.textContent = '...';\n\n    // Clear vendor\n    detailsVendor.innerHTML = `\n        <h4>Vendor Analysis</h4>\n        <div class=\"vendor-info\">\n            <i class=\"fas fa-question-circle\"></i>\n            <span>Scanning...</span>\n        </div>`;\n    \n    // Clear signature\n    detailsSignature.innerHTML = `\n        <h4>Digital Signature</h4>\n        <div class=\"signature-info\">\n            <i class=\"fas fa-question-circle\"></i>\n            <span>Checking...</span>\n        </div>`;\n    \n    // Clear internals\n    entropyBarsContainer.innerHTML = '';\n    keyStringsContainer.innerHTML = '';\n    \n    // Clear graph\n    callGraphEl.innerHTML = '';\n    currentGraphLines.forEach(line => line.remove());\n    currentGraphLines = [];\n    \n    // Hide AI-specific sections\n    if (aiVotingSection) aiVotingSection.style.display = 'none';\n    if (peMetadataSection) peMetadataSection.style.display = 'none';\n}\n\n// --- QR helpers ---\nfunction clearQr() {\n    const qrSection = document.getElementById('qr-section');\n    const qrEl = document.getElementById('qr-code');\n    if (qrEl) qrEl.innerHTML = '';\n    if (qrSection) qrSection.style.display = 'none';\n}\n\nfunction generatePeQr(scanResult) {\n    const qrSection = document.getElementById('qr-section');\n    const qrEl = document.getElementById('qr-code');\n    if (!qrEl || !qrSection || typeof QRCode === 'undefined') return;\n\n    // Build a compact JSON report that fits in a QR\n    const report = {\n        filename: scanResult.detected_filename,\n        classification: scanResult.classification,\n        confidence: Number(scanResult.confidence_score),\n        family: scanResult.malware_family || null,\n        vendor: (scanResult.vendor && scanResult.vendor.name) ? scanResult.vendor.name : null,\n        hashes: {\n            sha256: scanResult.file_hashes?.sha256 || null,\n            md5: scanResult.file_hashes?.md5 || null\n        },\n        ts: Date.now()\n    };\n\n    // Show section and render\n    qrSection.style.display = 'block';\n    qrEl.innerHTML = '';\n    const json = JSON.stringify(report);\n    try {\n        new QRCode(qrEl, { text: json, width: 160, height: 160, colorDark: '#000', colorLight: '#fff', correctLevel: QRCode.CorrectLevel.M });\n    } catch (e) {\n        console.warn('QR generation failed', e);\n        qrEl.textContent = 'QR unavailable';\n    }\n}\n\n// --- VENDOR UI FUNCTION (IMPLEMENTED) ---\nfunction populateVendor(vendor) {\n    if (!vendor) return;\n    const icon = vendor.icon || 'fas fa-question-circle'; //\n    const name = vendor.name || 'Unknown'; //\n    detailsVendor.innerHTML = `\n        <h4>Vendor Analysis</h4> <div class=\"vendor-info\"> <i class=\"${icon}\"></i>\n            <span>${name}</span>\n        </div>\n    `;\n}\n\n// --- SIGNATURE UI FUNCTION (IMPLEMENTED) ---\nfunction populateSignature(signature) {\n    if (!signature) return;\n    let icon = signature.icon || 'fas fa-question-circle';\n    let cssClass = `sig-${signature.level || 'unknown'}`; // 'sig-verified', 'sig-untrusted', 'sig-unknown'\n\n    detailsSignature.innerHTML = `\n        <h4>Digital Signature</h4> <div class=\"signature-info ${cssClass}\"> <i class=\"${icon}\"></i>\n            <span>${signature.name}</span>\n        </div>\n    `;\n}\n\n// --- ENTROPY BARS UI FUNCTION (IMPLEMENTED) ---\nfunction populateEntropyBars(sections) {\n    entropyBarsContainer.innerHTML = ''; // Clear old bars\n    if (!sections || sections.length === 0) {\n        entropyBarsContainer.innerHTML = '<p class=\"hash-text\">No PE sections found to analyze.</p>';\n        return;\n    }\n\n    sections.forEach(section => { //\n        const value = section.entropy; //\n        const width = (value / 8.0) * 100; // Entropy is 0-8\n        let cssClass = 'low';\n        \n        if (value > 6.0) cssClass = 'medium';\n        if (value > 7.0) cssClass = 'high';\n        if (value > 7.8) cssClass = 'packed'; // Match style.css\n\n        const row = document.createElement('div');\n        row.className = 'entropy-bar-row';\n        row.innerHTML = `\n            <span class=\"entropy-bar-label\">${section.name}</span> <div class=\"entropy-bar-bg\">\n                <div class=\"entropy-bar-fill ${cssClass}\" style=\"width: ${width}%\">\n                    <span class=\"entropy-bar-value\">${value.toFixed(2)}</span>\n                </div>\n            </div>\n        `;\n        entropyBarsContainer.appendChild(row);\n    });\n}\n\n// --- KEY STRINGS UI FUNCTION (IMPLEMENTED) ---\nfunction populateKeyStrings(strings, classification) {\n    keyStringsContainer.innerHTML = ''; // Clear old strings\n    if (!strings || strings.length === 0) {\n        keyStringsContainer.innerHTML = '<span class=\"key-string-tag\">No notable strings found.</span>';\n        return;\n    }\n    \n    const tagClass = classification.includes('Benign') ? 'benign' : 'suspicious'; //\n\n    strings.forEach(str => { //\n        const tag = document.createElement('span');\n        tag.className = `key-string-tag ${tagClass}`;\n        tag.textContent = str;\n        keyStringsContainer.appendChild(tag);\n    });\n}\n\nfunction updateSystemIpDisplay() {\n    if (!detailsSystemIp || !window.electronAPI || typeof window.electronAPI.getSystemIp !== 'function') {\n        return;\n    }\n\n    detailsSystemIp.textContent = 'Detecting...';\n\n    window.electronAPI.getSystemIp()\n        .then((ip) => {\n            if (!ip) {\n                detailsSystemIp.textContent = 'Unavailable';\n                return;\n            }\n\n            detailsSystemIp.textContent = ip;\n        })\n        .catch(() => {\n            detailsSystemIp.textContent = 'Unavailable';\n        });\n}\n\nfunction removeAnimationClasses() {\n    bodyEl.classList.remove('result-safe-active');\n    bodyEl.classList.remove('result-suspicious-active');\n    bodyEl.classList.remove('result-malware-active');\n}\n\n// --- AI VOTING UI FUNCTION ---\nfunction populateAIVoting(votingData) {\n    if (!votingData || !aiVotingSection) {\n        if (aiVotingSection) aiVotingSection.style.display = 'none';\n        return;\n    }\n    \n    const benignVotes = votingData.benign || 0;\n    const malwareVotes = votingData.malware || 0;\n    const totalVotes = votingData.total_models || (benignVotes + malwareVotes);\n    \n    if (totalVotes === 0) {\n        aiVotingSection.style.display = 'none';\n        return;\n    }\n    \n    // Calculate percentages\n    const benignPercent = (benignVotes / totalVotes) * 100;\n    const malwarePercent = (malwareVotes / totalVotes) * 100;\n    \n    // Update vote bars\n    voteBarBenign.style.width = `${benignPercent}%`;\n    voteBarMalware.style.width = `${malwarePercent}%`;\n    voteCountBenign.textContent = benignVotes;\n    voteCountMalware.textContent = malwareVotes;\n    \n    aiVotingSection.style.display = 'block';\n}\n\n// --- PE METADATA UI FUNCTION ---\nfunction populatePeMetadata(metadata) {\n    if (!metadata || !peMetadataSection) {\n        if (peMetadataSection) peMetadataSection.style.display = 'none';\n        return;\n    }\n    \n    // Format file size\n    const fileSize = metadata.file_size || 0;\n    let sizeStr = fileSize + ' bytes';\n    if (fileSize > 1024 * 1024) {\n        sizeStr = (fileSize / (1024 * 1024)).toFixed(2) + ' MB';\n    } else if (fileSize > 1024) {\n        sizeStr = (fileSize / 1024).toFixed(2) + ' KB';\n    }\n    \n    peFileSize.textContent = sizeStr;\n    peEntropyTotal.textContent = metadata.entropy_total ? metadata.entropy_total.toFixed(2) : '-';\n    peSectionsCount.textContent = metadata.number_of_sections || '-';\n    peDllsCount.textContent = metadata.total_dlls || '-';\n    peResourcesCount.textContent = metadata.total_resources || '-';\n    peIsPacked.textContent = metadata.is_packed ? 'Yes' : 'No';\n    peIsPacked.style.color = metadata.is_packed ? 'var(--red)' : 'var(--green)';\n    \n    peMetadataSection.style.display = 'block';\n}\n\n// --- Reset to Initial State Function ---\nfunction resetToInitialState() {\n    // Clear any running intervals\n    if (disassemblyInterval) {\n        clearInterval(disassemblyInterval);\n        disassemblyInterval = null;\n    }\n    \n    // Remove all state classes from body\n    bodyEl.classList.remove('is-analyzing');\n    bodyEl.classList.remove('is-showing-result');\n    bodyEl.classList.remove('is-non-pe');\n    removeAnimationClasses();\n    \n    // Hide all states except initial\n    initialState.classList.add('active');\n    analyzingState.classList.remove('active');\n    resultState.classList.remove('active');\n    nonPeResultWrapper.classList.remove('active');\n    \n    // Clear any error messages\n    if (manualScanError) {\n        manualScanError.textContent = '';\n    }\n    \n    // Scroll to top smoothly\n    window.scrollTo({ top: 0, behavior: 'smooth' });\n}\n\n// --- Disassembly Functions ---\n\nfunction populateDisassembly(codeLines) {\n    disassemblyCodeEl.innerHTML = '';\n    codeLines.forEach((line, index) => {\n        const lineEl = document.createElement('span');\n        lineEl.className = 'disassembly-line';\n        lineEl.id = `line-${index}`;\n        lineEl.innerHTML = line;\n        disassemblyCodeEl.appendChild(lineEl);\n    });\n}\n\nfunction startDisassemblyAnimation() {\n    if (disassemblyInterval) {\n        clearInterval(disassemblyInterval);\n    }\n    let currentLine = 0;\n    const totalLines = disassemblyCodeEl.children.length;\n\n    disassemblyInterval = setInterval(() => {\n        const prevLine = document.querySelector('.disassembly-line.active');\n        if (prevLine) {\n            prevLine.classList.remove('active');\n        }\n\n        const lineEl = document.getElementById(`line-${currentLine}`);\n        if (lineEl) {\n            lineEl.classList.add('active');\n            lineEl.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center',\n                inline: 'nearest'\n            });\n        }\n        currentLine = (currentLine + 1) % totalLines;\n    }, 150);\n}\n\n/**\n * This function was MOVED here from jsonsamples.js\n * Dynamically generates the graph data based on API imports.\n * @param {string[]} apiImports - Array of API names (e.g., ['CreateRemoteThread'])\n * @param {string} classification - 'Benign', 'Suspicious', or 'Malware'\n * @returns {object} A graph object with 'nodes' and 'edges' arrays.\n */\nfunction generateGraphData(apiImports, classification) {\n    let nodes = [];\n    let edges = [];\n    const nodeSpacing = 150;\n    const startY = 100;\n    const startX = 250;\n\n    // 1. Add the Main Entry Point node\n    nodes.push({ \n        id: 'main-entry', \n        label: 'main()', \n        class: 'node-entry', \n        pos: { top: `${startY + (apiImports.length / 2) * (nodeSpacing / 2)}px`, left: '50px' } \n    });\n\n    if (!apiImports || apiImports.length === 0) {\n        // Benign/Empty graph\n        nodes.push({ id: 'benign-1', label: 'ReadFile', class: 'node-std', pos: { top: `${startY}px`, left: `${startX}px` } });\n        nodes.push({ id: 'benign-2', label: 'WriteFile', class: 'node-std', pos: { top: `${startY + nodeSpacing / 2}px`, left: `${startX}px` } });\n        edges.push({ from: 'main-entry', to: 'benign-1', options: { color: '#888' } });\n        edges.push({ from: 'main-entry', to: 'benign-2', options: { color: '#888' } });\n    } else {\n        // Suspicious/Malware graph\n        apiImports.forEach((apiName, index) => {\n            let nodeClass = 'node-api'; // Default\n            let edgeColor = '#888'; // Default\n\n            if (classification === 'Malware') {\n                nodeClass = 'node-malicious';\n                edgeColor = '#e74c3c'; // Malware red\n            } else if (classification === 'Suspicious') {\n                nodeClass = 'node-suspicious';\n                edgeColor = '#f1c40f'; // Suspicious yellow\n            } else {\n                // Benign\n                nodeClass = 'node-std';\n                edgeColor = '#888';\n            }\n\n\n            const nodeId = `api-${index}`;\n            const yPos = startY + (index * (nodeSpacing-50)); // Make them a bit closer\n            const xPos = startX + (index % 2 === 0 ? 0 : 150); // Stagger them\n\n            // Add the API node\n            nodes.push({\n                id: nodeId,\n                label: apiName,\n                class: nodeClass,\n                pos: { top: `${yPos}px`, left: `${xPos}px` }\n            });\n\n            // Add the edge from main\n            edges.push({\n                from: 'main-entry',\n                to: nodeId,\n                options: { color: edgeColor }\n            });\n        });\n    }\n\n    return { nodes, edges };\n}\n\n// --- Graph Drawing ---\nfunction drawCallGraph(graphData) {\n    // 1. Clear previous graph (both nodes and lines)\n    callGraphEl.innerHTML = '';\n    currentGraphLines.forEach(line => line.remove());\n    currentGraphLines = [];\n\n    if (!graphData || !graphData.nodes || !graphData.edges) {\n        console.error(\"Invalid graph data received\", graphData);\n        return;\n    }\n\n    // 2. Create and place all nodes\n    graphData.nodes.forEach(node => {\n        const nodeEl = document.createElement('div');\n        nodeEl.id = node.id;\n        nodeEl.className = `graph-node ${node.class}`;\n        nodeEl.style.top = node.pos.top;\n        nodeEl.style.left = node.pos.left;\n        nodeEl.textContent = node.label;\n        callGraphEl.appendChild(nodeEl);\n    });\n\n    // 3. Draw all edges (must be done *after* nodes are in DOM)\n    // Use a slight timeout to ensure DOM is ready\n    setTimeout(() => {\n        graphData.edges.forEach(edge => {\n            try {\n                const line = new LeaderLine(\n                    document.getElementById(edge.from),\n                    document.getElementById(edge.to),\n                    {\n                        color: edge.options.color,\n                        path: edge.options.path || 'straight',\n                        startSocket: edge.options.startSocket || 'auto',\n                        endSocket: edge.options.endSocket || 'auto',\n                        endPlug: 'arrow1',\n                        size: 3,\n                        endPlugSize: 1.5,\n                    }\n                );\n                currentGraphLines.push(line);\n            } catch(e) {\n                console.error(\"Could not draw line:\", e);\n            }\n        });\n    }, 500); // 500ms timeout to let CSS fade-in finish\n}\n\n\n// --- History Panel Logic ---\nasync function loadHistory() {\n  if (!historyListEl) return;\n  \n  historyListEl.innerHTML = '<li class=\"history-item-loading\">Loading...</li>';\n\n  try {\n    const historyData = await window.electronAPI.getHistory();\n\n    if (!historyData || historyData.length === 0) {\n      historyListEl.innerHTML = '<li class=\"history-item-empty\">No scan history found.</li>';\n      return;\n    }\n\n    historyListEl.innerHTML = '';\n\n    historyData.forEach(scan => {\n      const li = document.createElement('li');\n      li.className = 'history-item';\n\n      // Determine classification icon\n      let statusIcon = 'fas fa-check-circle';\n      let classType = 'safe';\n      if (scan.classification.includes('Malware')) {\n        statusIcon = 'fas fa-bug';\n        classType = 'malware';\n      } else if (scan.classification.includes('Suspicious')) {\n        statusIcon = 'fas fa-exclamation-triangle';\n        classType = 'suspicious';\n      }\n\n      // Determine file type icon based on extension\n      const filename = scan.detected_filename || '';\n      const ext = filename.split('.').pop().toLowerCase();\n      let fileTypeIcon = 'fas fa-file';\n      \n      if (['exe', 'dll', 'sys', 'msi'].includes(ext)) {\n        fileTypeIcon = 'fas fa-cog'; // Executable\n      } else if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(ext)) {\n        fileTypeIcon = 'fas fa-image'; // Image\n      } else if (['js', 'ts', 'py', 'java', 'cpp', 'c', 'h', 'cs', 'go', 'rs', 'php', 'rb'].includes(ext)) {\n        fileTypeIcon = 'fas fa-code'; // Code\n      } else if (['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'].includes(ext)) {\n        fileTypeIcon = 'fas fa-file-alt'; // Document\n      } else if (['zip', 'rar', '7z', 'tar', 'gz', 'bz2'].includes(ext)) {\n        fileTypeIcon = 'fas fa-file-archive'; // Archive\n      } else if (['mp3', 'wav', 'ogg', 'flac', 'aac'].includes(ext)) {\n        fileTypeIcon = 'fas fa-file-audio'; // Audio\n      } else if (['mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv'].includes(ext)) {\n        fileTypeIcon = 'fas fa-file-video'; // Video\n      } else if (['html', 'htm', 'css', 'xml', 'json'].includes(ext)) {\n        fileTypeIcon = 'fas fa-file-code'; // Web file\n      }\n\n      const scanDate = new Date(scan.scanDate).toLocaleString();\n      const hashSha256 = scan.file_hashes?.sha256 || 'N/A';\n      const hashDisplay = hashSha256.substring(0, 16) + '...'; // Show first 16 chars\n\n      li.innerHTML = `\n        <div class=\"history-icon-wrapper\">\n          <div class=\"history-icon ${classType}\">\n            <i class=\"${statusIcon}\"></i>\n          </div>\n          <div class=\"history-file-type\">\n            <i class=\"${fileTypeIcon}\"></i>\n          </div>\n        </div>\n        <div class=\"history-details\">\n          <span class=\"history-filename\" title=\"${filename}\">${filename}</span>\n          <span class=\"history-classification ${classType}\">${scan.classification}</span>\n          <span class=\"history-hash\" title=\"${hashSha256}\">SHA256: ${hashDisplay}</span>\n        </div>\n        <span class=\"history-date\">${scanDate}</span>\n      `;\n      \n      historyListEl.appendChild(li);\n    });\n\n  } catch (err) {\n    console.error('Failed to load history:', err);\n    historyListEl.innerHTML = '<li class=\"history-item-empty\">Error loading history.</li>';\n  }\n}\n\nfunction toggleHistoryPanel() {\n  bodyEl.classList.toggle('is-history-open');\n  \n  // ADD THIS: If we are opening the panel, load the history\n  if (bodyEl.classList.contains('is-history-open')) {\n    loadHistory();\n  }\n}\n\n// Home button event listener\nhomeBtn.addEventListener('click', (e) => {\n    e.preventDefault();\n    resetToInitialState();\n});\n\nhistoryBtn.addEventListener('click', (e) => {\n    e.preventDefault();\n    toggleHistoryPanel();\n});\nhistoryCloseBtn.addEventListener('click', toggleHistoryPanel);\nhistoryOverlay.addEventListener('click', toggleHistoryPanel);\n\n\n// --- Auto-scroll Logic ---\nfunction startScrolling(direction) {\n    if (scrollInterval) {\n        clearInterval(scrollInterval);\n    }\n    scrollInterval = setInterval(() => {\n        window.scrollBy(0, direction * 10); // 10 pixels at a time\n    }, 20); // every 20ms\n}\n\nfunction stopScrolling() {\n    clearInterval(scrollInterval);\n    scrollInterval = null;\n}\n\nscrollZoneTop.addEventListener('mouseenter', () => {\n    startScrolling(-1); // Scroll Up\n    scrollZoneTop.classList.add('scrolling');\n});\nscrollZoneTop.addEventListener('mouseleave', () => {\n    stopScrolling();\n    scrollZoneTop.classList.remove('scrolling');\n});\n\nscrollZoneBottom.addEventListener('mouseenter', () => {\n    startScrolling(1); // Scroll Down\n    scrollZoneBottom.classList.add('scrolling');\n});\nscrollZoneBottom.addEventListener('mouseleave', () => {\n    stopScrolling();\n    scrollZoneBottom.classList.remove('scrolling');\n});\n\n\n// --- Chart instances ---\nlet malwareTypesChart = null;\nlet topMalwareChart = null;\n\n// --- Function to create/recreate charts ---\nwindow.recreateCharts = function() {\n    // Check if light theme is active\n    const isLightTheme = document.body.classList.contains('light-theme');\n    \n    // Set colors based on theme\n    const chartLegendColor = isLightTheme ? '#6c757d' : '#e0e0e0';\n    const chartAxesColor = isLightTheme ? '#6c757d' : '#aaa';\n    const chartGridColor = isLightTheme ? '#dee2e6' : '#444444';\n\n    // Destroy existing charts if they exist\n    if (malwareTypesChart) {\n        malwareTypesChart.destroy();\n    }\n    if (topMalwareChart) {\n        topMalwareChart.destroy();\n    }\n\n    // Create Malware Types Chart (Doughnut)\n    const typesCtx = document.getElementById('malwareTypesChart');\n    if (typesCtx) {\n        malwareTypesChart = new Chart(typesCtx, {\n            type: 'doughnut',\n            data: {\n                labels: ['PE (exe/dll)', 'JavaScript', 'VBS', 'Macro', 'Other'],\n                datasets: [{\n                    label: 'Submission Types',\n                    data: [65, 15, 8, 7, 5],\n                    backgroundColor: [\n                        '#007bff', // Blue\n                        '#f1c40f', // Yellow\n                        '#e74c3c', // Red\n                        '#9b59b6', // Purple\n                        '#34495e'  // Gray\n                    ],\n                    borderColor: '#2a2a2e',\n                    borderWidth: 3,\n                }]\n            },\n            options: {\n                responsive: true,\n                plugins: {\n                    legend: {\n                        position: 'right',\n                        labels: {\n                            color: chartLegendColor,\n                            boxWidth: 20\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    // Create Top Malware Chart (Line)\n    const topMalwareCtx = document.getElementById('topMalwareChart');\n    if (topMalwareCtx) {\n        topMalwareChart = new Chart(topMalwareCtx, {\n            type: 'line',\n            data: {\n                labels: ['Week 1', 'Week 2', 'Week 3', 'Week 4', 'Week 5'],\n                datasets: [\n                    {\n                        label: 'Zeus',\n                        data: [120, 150, 130, 180, 160],\n                        borderColor: '#e74c3c',\n                        backgroundColor: '#e74c3c20',\n                        fill: true,\n                        tension: 0.4\n                    },\n                    {\n                        label: 'WannaCry',\n                        data: [80, 90, 110, 100, 130],\n                        borderColor: '#007bff',\n                        backgroundColor: '#007bff20',\n                        fill: true,\n                        tension: 0.4\n                    },\n                    {\n                        label: 'Emotet',\n                        data: [50, 60, 80, 70, 90],\n                        borderColor: '#f1c40f',\n                        backgroundColor: '#f1c40f20',\n                        fill: true,\n                        tension: 0.4\n                    }\n                ]\n            },\n            options: {\n                responsive: true,\n                plugins: {\n                    legend: {\n                        labels: {\n                            color: chartLegendColor\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        ticks: { color: chartAxesColor },\n                        grid: { color: chartGridColor + '50' }\n                    },\n                    y: {\n                        ticks: { color: chartAxesColor },\n                        grid: { color: chartGridColor }\n                    }\n                }\n            }\n        });\n    }\n};\n\n// --- NAVIGATION FUNCTIONS ---\nfunction updateNavigationButtons() {\n    const prevBtn = document.getElementById('prev-scan-btn');\n    const nextBtn = document.getElementById('next-scan-btn');\n    const navInfo = document.getElementById('nav-info');\n    \n    if (!prevBtn || !nextBtn) return;\n    \n    // Disable/enable buttons based on position\n    prevBtn.disabled = currentHistoryIndex <= 0;\n    nextBtn.disabled = currentHistoryIndex >= scanHistory.length - 1;\n    \n    // Update info text\n    if (navInfo && scanHistory.length > 0) {\n        navInfo.textContent = `${currentHistoryIndex + 1} of ${scanHistory.length}`;\n    }\n}\n\nfunction showPreviousScan() {\n    if (currentHistoryIndex > 0) {\n        currentHistoryIndex--;\n        lastScanResult = scanHistory[currentHistoryIndex];\n        renderScanResult();\n        updateNavigationButtons();\n    }\n}\n\nfunction showNextScan() {\n    if (currentHistoryIndex < scanHistory.length - 1) {\n        currentHistoryIndex++;\n        lastScanResult = scanHistory[currentHistoryIndex];\n        renderScanResult();\n        updateNavigationButtons();\n    }\n}\n\n// Initialize history from electron-store on load\nasync function initializeScanHistory() {\n    try {\n        const storedHistory = await window.electronAPI.getHistory();\n        if (storedHistory && Array.isArray(storedHistory)) {\n            scanHistory = storedHistory;\n            currentHistoryIndex = scanHistory.length - 1;\n        }\n    } catch (error) {\n        console.error('Failed to load scan history:', error);\n    }\n}\n\n// --- Run on Page Load ---\ndocument.addEventListener('DOMContentLoaded', () => {\n    // 1. Animate Stat Cards\n    const statNumbers = document.querySelectorAll('.stat-number');\n    statNumbers.forEach(stat => {\n        const target = +stat.getAttribute('data-target');\n        const duration = 2000;\n        const stepTime = 20;\n        const steps = duration / stepTime;\n        const increment = target / steps;\n        let current = 0;\n\n        const updateCount = () => {\n            current += increment;\n            if (current < target) {\n                stat.textContent = Math.ceil(current).toLocaleString();\n                setTimeout(updateCount, stepTime);\n            } else {\n                stat.textContent = target.toLocaleString();\n            }\n        };\n        updateCount();\n    });\n\n    // 2. Create the charts\n    recreateCharts();\n    \n    // 3. Initialize scan history\n    initializeScanHistory();\n    \n    // 4. Setup navigation button handlers\n    const prevBtn = document.getElementById('prev-scan-btn');\n    const nextBtn = document.getElementById('next-scan-btn');\n    \n    if (prevBtn) prevBtn.addEventListener('click', showPreviousScan);\n    if (nextBtn) nextBtn.addEventListener('click', showNextScan);\n});\n","epoch":23,"telemetryInfo":{}}],["file:///home/trang/localnsv/mAIware---AI/requirements.txt::request_cea1c3f5-681f-43b2-927b-2bd12d471bbb",{"uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware---AI/requirements.txt","external":"file:///home/trang/localnsv/mAIware---AI/requirements.txt","path":"/home/trang/localnsv/mAIware---AI/requirements.txt","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","content":"joblib==1.5.2\nlightgbm==4.6.0\nnumpy==2.3.5\nnvidia-nccl-cu12==2.28.9\npandas==2.3.3\npefile==2024.8.26\npython-dateutil==2.9.0.post0\npytz==2025.2\nscikit-learn==1.7.2\nscipy==1.16.3\nsix==1.17.0\nthreadpoolctl==3.6.0\ntzdata==2025.2\nxgboost==3.1.2\n","epoch":28,"telemetryInfo":{}}]],"operations":[{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware/ai-client.js","external":"file:///home/trang/localnsv/mAIware/ai-client.js","path":"/home/trang/localnsv/mAIware/ai-client.js","scheme":"file"},"requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","epoch":4,"edits":[{"text":"/**\n * Build a complete scan result from AI prediction\n * @param {string} filePath - Original file path\n * @param {object} fileHashes - SHA256 and MD5\n * @param {object} aiResult - AI model output\n * @returns {object} - Complete scan result matching UI expectations\n */\nfunction buildScanResult(filePath, fileHashes, aiResult) {\n  const filename = path.basename(filePath);\n  \n  // Select appropriate vendor based on classification\n  let vendor = VENDORS[15]; // Default: \"mAIware AI Engine\"\n  if (aiResult.classification === 'Malware') {\n    vendor = VENDORS[6]; // Windows Defender (red icon)\n  } else if (aiResult.classification === 'Benign') {\n    vendor = VENDORS[2]; // Microsoft (verified)\n  }\n  \n  // Determine signature status\n  let signature = SIGNATURES[4]; // Default: Not Signed\n  if (aiResult.classification === 'Benign' && Math.random() > 0.5) {\n    signature = SIGNATURES[0]; // Microsoft Corporation (verified)\n  } else if (aiResult.classification === 'Suspicious') {\n    signature = SIGNATURES[4]; // Unknown/Not Signed\n  } else if (aiResult.classification === 'Malware') {\n    signature = SIGNATURES[3]; // Self-signed\n  }\n\n  const result = {\n    detected_filename: filename,\n    file_hashes: fileHashes || { sha256: '', md5: '' },\n    classification: aiResult.classification,\n    confidence_score: aiResult.confidence_score,\n    is_pe: true,\n    vendor: vendor,\n    key_findings: {\n      file_type: aiResult.file_type || 'PE Executable',\n      packer_detected: aiResult.packer_detected || 'Unknown',\n      signature: signature,\n      section_entropy: aiResult.section_entropy || [],\n      api_imports: aiResult.api_imports || [],\n      key_strings: aiResult.key_strings || []\n    }\n  };\n\n  // Add AI-specific voting data (NEW from ensemble models)\n  if (aiResult.votes_benign !== undefined && aiResult.votes_malware !== undefined) {\n    result.votes_benign = aiResult.votes_benign;\n    result.votes_malware = aiResult.votes_malware;\n    result.ai_voting = {\n      benign: aiResult.votes_benign,\n      malware: aiResult.votes_malware,\n      total_models: aiResult.votes_benign + aiResult.votes_malware\n    };\n  }\n\n  // Add PE feature metadata (NEW from AI model)\n  if (aiResult.pe_features) {\n    result.pe_metadata = {\n      file_size: aiResult.pe_features.file_size,\n      entropy_total: aiResult.pe_features.entropy_total,\n      number_of_sections: aiResult.pe_features.number_of_sections,\n      total_dlls: aiResult.pe_features.total_dlls,\n      total_resources: aiResult.pe_features.total_resources,\n      is_packed: aiResult.pe_features.is_packed\n    };\n  }\n\n  return result;\n}","range":{"startLineNumber":89,"startColumn":1,"endLineNumber":156,"endColumn":2}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware---AI/predict_single.py","external":"file:///home/trang/localnsv/mAIware---AI/predict_single.py","path":"/home/trang/localnsv/mAIware---AI/predict_single.py","scheme":"file"},"requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","epoch":7,"edits":[{"text":"        result = {\n            \"classification\": ensemble_class.capitalize(),  # Benign/Suspicious/Malware\n            \"confidence_score\": round(ensemble_score, 2),\n            \"votes_benign\": int(row.get('votes_benign', 0)),\n            \"votes_malware\": int(row.get('votes_malware', 0)),\n            \"ensemble_label\": int(row.get('ensemble_label', 0)),  # 0=benign, 1=malware\n            \"ensemble_score\": round(ensemble_score, 2),\n            \"ensemble_class\": ensemble_class,  # benign/suspicious/malware\n            \"ensemble_class_id\": int(row.get('ensemble_class_id', 1)),  # 0/1/2\n            \"file_type\": file_type,\n            \"packer_detected\": packer,\n            \"section_entropy\": sections,\n            \"api_imports\": imports,\n            \"key_strings\": strings,\n            \"pe_features\": {\n                \"file_size\": int(feature_row.get('FileSize', 0)),\n                \"entropy_total\": round(float(feature_row.get('Entropy_Total', 0)), 2),\n                \"number_of_sections\": int(feature_row.get('NumberOfSections', 0)),\n                \"total_dlls\": int(feature_row.get('Total_DLLs', 0)),\n                \"total_resources\": int(feature_row.get('Total_Resources', 0)),\n                \"is_packed\": int(feature_row.get('Packed', 0)) == 1\n            }\n        }","range":{"startLineNumber":172,"startColumn":1,"endLineNumber":190,"endColumn":10}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware/ai-client.js","external":"file:///home/trang/localnsv/mAIware/ai-client.js","path":"/home/trang/localnsv/mAIware/ai-client.js","scheme":"file"},"requestId":"request_3f8c43eb-e769-4b31-b18f-28aa1315741b","epoch":9,"edits":[{"text":"  const result = {\n    detected_filename: filename,\n    file_hashes: fileHashes || { sha256: '', md5: '' },\n    classification: aiResult.classification,\n    confidence_score: aiResult.confidence_score,\n    is_pe: true,\n    vendor: vendor,\n    key_findings: {\n      file_type: aiResult.file_type || 'PE Executable',\n      packer_detected: aiResult.packer_detected || 'Unknown',\n      signature: signature,\n      section_entropy: aiResult.section_entropy || [],\n      api_imports: aiResult.api_imports || [],\n      key_strings: aiResult.key_strings || []\n    }\n  };\n\n  // Add AI-specific voting data (NEW from ensemble models)\n  if (aiResult.votes_benign !== undefined && aiResult.votes_malware !== undefined) {\n    result.votes_benign = aiResult.votes_benign;\n    result.votes_malware = aiResult.votes_malware;\n    result.ai_voting = {\n      benign: aiResult.votes_benign,\n      malware: aiResult.votes_malware,\n      total_models: aiResult.votes_benign + aiResult.votes_malware\n    };\n  }\n\n  // Add ensemble-specific fields (NEW from AI model CSV output)\n  if (aiResult.ensemble_label !== undefined) {\n    result.ensemble_label = aiResult.ensemble_label;\n  }\n  if (aiResult.ensemble_score !== undefined) {\n    result.ensemble_score = aiResult.ensemble_score;\n  }\n  if (aiResult.ensemble_class !== undefined) {\n    result.ensemble_class = aiResult.ensemble_class;\n  }\n  if (aiResult.ensemble_class_id !== undefined) {\n    result.ensemble_class_id = aiResult.ensemble_class_id;\n  }\n\n  // Add PE feature metadata (NEW from AI model)\n  if (aiResult.pe_features) {\n    result.pe_metadata = {\n      file_size: aiResult.pe_features.file_size,\n      entropy_total: aiResult.pe_features.entropy_total,\n      number_of_sections: aiResult.pe_features.number_of_sections,\n      total_dlls: aiResult.pe_features.total_dlls,\n      total_resources: aiResult.pe_features.total_resources,\n      is_packed: aiResult.pe_features.is_packed\n    };\n  }\n\n  return result;","range":{"startLineNumber":117,"startColumn":1,"endLineNumber":157,"endColumn":17}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware---AI/predict_single.py","external":"file:///home/trang/localnsv/mAIware---AI/predict_single.py","path":"/home/trang/localnsv/mAIware---AI/predict_single.py","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","epoch":14,"edits":[{"text":"#!/usr/bin/env python3\n\"\"\"Predict a single PE file and output comprehensive JSON with features.\"\"\"\nimport json\nimport sys\nfrom pathlib import Path\nimport pefile\n\nfrom ensemble_predict_dir import (\n    load_model_columns, extract_features, prepare_feature_matrix,\n    run_models, DEFAULT_MODELS_DIR, DEFAULT_MODEL_COLS, DEFAULT_MODELS\n)\nfrom ensemble_vote import run_majority_voting\nimport pe_to_features\n\n# Import angr for call graph extraction (optional)\ntry:\n    import angr\n    import networkx as nx\n    ANGR_AVAILABLE = True\nexcept ImportError:\n    ANGR_AVAILABLE = False\n    print(\"Warning: angr not available, call graph extraction disabled\", file=sys.stderr)","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":13,"endColumn":22}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware---AI/predict_single.py","external":"file:///home/trang/localnsv/mAIware---AI/predict_single.py","path":"/home/trang/localnsv/mAIware---AI/predict_single.py","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","epoch":16,"edits":[{"text":"def detect_packer(file_path: Path, sections: list) -> str:\n    \"\"\"Detect common packers based on section names and entropy.\"\"\"\n    try:\n        # Check for high entropy sections (packed indicator)\n        high_entropy_sections = [s for s in sections if s.get('entropy', 0) > 7.5]\n        \n        # Check for common packer section names\n        section_names = [s.get('name', '').upper() for s in sections]\n        \n        if 'UPX0' in section_names or 'UPX1' in section_names:\n            return 'UPX'\n        elif '.aspack' in [s.lower() for s in section_names]:\n            return 'ASPack'\n        elif '.petite' in [s.lower() for s in section_names]:\n            return 'Petite'\n        elif len(high_entropy_sections) >= 2:\n            return 'Possibly Packed (High Entropy)'\n        elif len(high_entropy_sections) == 1:\n            return 'Suspicious (Partial Packing)'\n        else:\n            return 'None Detected'\n    except Exception:\n        return 'Unknown'\n\n\ndef extract_callgraph_json(file_path: Path, max_nodes: int = 15) -> dict:\n    \"\"\"Extract call graph using angr and return JSON structure for UI.\"\"\"\n    if not ANGR_AVAILABLE:\n        return {\"error\": \"angr not available\", \"nodes\": [], \"edges\": []}\n    \n    try:\n        print(f\"[*] Extracting call graph from {file_path.name}...\", file=sys.stderr)\n        \n        # Load binary with angr\n        proj = angr.Project(str(file_path), auto_load_libs=False, load_debug_info=False)\n        \n        # Build CFG (fast mode)\n        cfg = proj.analyses.CFGFast()\n        \n        # Find entry function\n        entry_func = None\n        if proj.entry in cfg.kb.functions:\n            entry_func = cfg.kb.functions[proj.entry]\n        else:\n            for f in cfg.kb.functions.values():\n                try:\n                    if f.contains_addr(proj.entry):\n                        entry_func = f\n                        break\n                except Exception:\n                    continue\n        \n        if entry_func is None:\n            return {\"error\": \"No entry function found\", \"nodes\": [], \"edges\": []}\n        \n        # Get call graph and limit nodes using BFS\n        callgraph = cfg.kb.callgraph\n        start_addr = entry_func.addr\n        \n        if start_addr not in callgraph:\n            return {\"error\": \"Entry not in call graph\", \"nodes\": [], \"edges\": []}\n        \n        # BFS to select limited nodes\n        selected = set()\n        queue = [start_addr]\n        \n        while queue and len(selected) < max_nodes:\n            node = queue.pop(0)\n            if node in selected:\n                continue\n            selected.add(node)\n            \n            # Add successors and predecessors\n            for successor in callgraph.successors(node):\n                if successor not in selected and successor not in queue:\n                    if len(selected) + len(queue) < max_nodes:\n                        queue.append(successor)\n            \n            for predecessor in callgraph.predecessors(node):\n                if predecessor not in selected and predecessor not in queue:\n                    if len(selected) + len(queue) < max_nodes:\n                        queue.append(predecessor)\n        \n        # Build subgraph\n        subgraph = callgraph.subgraph(selected)\n        \n        # Convert to JSON format for UI\n        nodes = []\n        edges = []\n        \n        for addr in subgraph.nodes():\n            func = cfg.kb.functions.get(addr)\n            if func and func.name:\n                name = func.name\n            else:\n                name = f\"sub_{hex(addr)[2:]}\"\n            \n            # Classify node type\n            node_class = \"node-std\"\n            if addr == start_addr:\n                node_class = \"node-entry\"\n            elif any(suspicious in name.lower() for suspicious in \n                    [\"inject\", \"allocate\", \"remote\", \"virtual\", \"create\", \"write\", \"exec\"]):\n                node_class = \"node-malicious\"\n            \n            nodes.append({\n                \"id\": hex(addr),\n                \"label\": name,\n                \"class\": node_class,\n                \"address\": hex(addr)\n            })\n        \n        for src, dst in subgraph.edges():\n            edges.append({\n                \"from\": hex(src),\n                \"to\": hex(dst)\n            })\n        \n        print(f\"[*] Extracted {len(nodes)} nodes and {len(edges)} edges\", file=sys.stderr)\n        return {\"nodes\": nodes, \"edges\": edges}\n        \n    except Exception as e:\n        print(f\"[!] Call graph extraction failed: {e}\", file=sys.stderr)\n        return {\"error\": str(e), \"nodes\": [], \"edges\": []}","range":{"startLineNumber":121,"startColumn":1,"endLineNumber":143,"endColumn":25}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware---AI/predict_single.py","external":"file:///home/trang/localnsv/mAIware---AI/predict_single.py","path":"/home/trang/localnsv/mAIware---AI/predict_single.py","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","epoch":18,"edits":[{"text":"        # Extract call graph (optional, can be slow)\n        callgraph_data = extract_callgraph_json(file_path, max_nodes=15)\n        \n        result = {\n            \"classification\": ensemble_class.capitalize(),  # Benign/Suspicious/Malware\n            \"confidence_score\": round(ensemble_score, 2),\n            \"votes_benign\": int(row.get('votes_benign', 0)),\n            \"votes_malware\": int(row.get('votes_malware', 0)),\n            \"ensemble_label\": int(row.get('ensemble_label', 0)),  # 0=benign, 1=malware\n            \"ensemble_score\": round(ensemble_score, 2),\n            \"ensemble_class\": ensemble_class,  # benign/suspicious/malware\n            \"ensemble_class_id\": int(row.get('ensemble_class_id', 1)),  # 0/1/2\n            \"file_type\": file_type,\n            \"packer_detected\": packer,\n            \"section_entropy\": sections,\n            \"api_imports\": imports,\n            \"key_strings\": strings,\n            \"call_graph\": callgraph_data,\n            \"pe_features\": {\n                \"file_size\": int(feature_row.get('FileSize', 0)),\n                \"entropy_total\": round(float(feature_row.get('Entropy_Total', 0)), 2),\n                \"number_of_sections\": int(feature_row.get('NumberOfSections', 0)),\n                \"total_dlls\": int(feature_row.get('Total_DLLs', 0)),\n                \"total_resources\": int(feature_row.get('Total_Resources', 0)),\n                \"is_packed\": int(feature_row.get('Packed', 0)) == 1\n            }\n        }\n        \n        return result","range":{"startLineNumber":282,"startColumn":1,"endLineNumber":306,"endColumn":22}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware/ai-client.js","external":"file:///home/trang/localnsv/mAIware/ai-client.js","path":"/home/trang/localnsv/mAIware/ai-client.js","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","epoch":21,"edits":[{"text":"  const result = {\n    detected_filename: filename,\n    file_hashes: fileHashes || { sha256: '', md5: '' },\n    classification: aiResult.classification,\n    confidence_score: aiResult.confidence_score,\n    is_pe: true,\n    vendor: vendor,\n    key_findings: {\n      file_type: aiResult.file_type || 'PE Executable',\n      packer_detected: aiResult.packer_detected || 'Unknown',\n      signature: signature,\n      section_entropy: aiResult.section_entropy || [],\n      api_imports: aiResult.api_imports || [],\n      key_strings: aiResult.key_strings || []\n    }\n  };\n\n  // Add call graph data if available (NEW from angr extraction)\n  if (aiResult.call_graph) {\n    result.call_graph = aiResult.call_graph;\n  }","range":{"startLineNumber":117,"startColumn":1,"endLineNumber":132,"endColumn":5}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware/script.js","external":"file:///home/trang/localnsv/mAIware/script.js","path":"/home/trang/localnsv/mAIware/script.js","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","epoch":24,"edits":[{"text":"  populateDisassembly(resultMockDisassembly); //\n\n  // Use real call graph if available, otherwise generate from API imports\n  let graphData;\n  if (scanResult.call_graph && scanResult.call_graph.nodes && scanResult.call_graph.nodes.length > 0) {\n    graphData = convertCallGraphToUI(scanResult.call_graph, scanResult.classification);\n  } else {\n    const apiList = scanResult.key_findings.api_imports || [];\n    graphData = generateGraphData(apiList, scanResult.classification);\n  }\n  drawCallGraph(graphData);\n  \n  // Populate AI-specific sections if data is available\n  populateAIVoting(scanResult.ai_voting);\n  populatePeMetadata(scanResult.pe_metadata);\n\n  // Generate QR for PE report\n  generatePeQr(scanResult);\n}","range":{"startLineNumber":352,"startColumn":1,"endLineNumber":364,"endColumn":2}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware/script.js","external":"file:///home/trang/localnsv/mAIware/script.js","path":"/home/trang/localnsv/mAIware/script.js","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","epoch":26,"edits":[{"text":"function convertCallGraphToUI(callGraph, classification) {\n    if (!callGraph || !callGraph.nodes || !callGraph.edges) {\n        return { nodes: [], edges: [] };\n    }\n    \n    const nodes = [];\n    const edges = [];\n    const nodeSpacing = 120;\n    const startX = 50;\n    const startY = 100;\n    \n    // Position nodes in a grid-like layout\n    callGraph.nodes.forEach((node, index) => {\n        const row = Math.floor(index / 3);\n        const col = index % 3;\n        \n        const xPos = startX + (col * 200);\n        const yPos = startY + (row * nodeSpacing);\n        \n        // Determine node color based on classification and node type\n        let nodeClass = node.class || 'node-std';\n        \n        // Override based on classification if not already entry/malicious\n        if (nodeClass === 'node-std' && classification === 'Malware') {\n            nodeClass = 'node-suspicious'; // Highlight in malware scans\n        }\n        \n        nodes.push({\n            id: node.id,\n            label: node.label,\n            class: nodeClass,\n            pos: { top: `${yPos}px`, left: `${xPos}px` }\n        });\n    });\n    \n    // Convert edges\n    callGraph.edges.forEach(edge => {\n        let edgeColor = '#888'; // Default\n        \n        if (classification === 'Malware') {\n            edgeColor = '#e74c3c';\n        } else if (classification === 'Suspicious') {\n            edgeColor = '#f1c40f';\n        }\n        \n        edges.push({\n            from: edge.from,\n            to: edge.to,\n            options: { color: edgeColor }\n        });\n    });\n    \n    return { nodes, edges };\n}\n\nfunction generateGraphData(apiImports, classification) {\n    let nodes = [];\n    let edges = [];\n    const nodeSpacing = 150;\n    const startY = 100;\n    const startX = 250;","range":{"startLineNumber":726,"startColumn":1,"endLineNumber":731,"endColumn":24}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/trang/localnsv/mAIware---AI/requirements.txt","external":"file:///home/trang/localnsv/mAIware---AI/requirements.txt","path":"/home/trang/localnsv/mAIware---AI/requirements.txt","scheme":"file"},"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","epoch":29,"edits":[{"text":"angr>=9.2.0\njoblib==1.5.2\nlightgbm==4.6.0\nnetworkx>=2.6\nnumpy==2.3.5\nnvidia-nccl-cu12==2.28.9\npandas==2.3.3\npefile==2024.8.26\npython-dateutil==2.9.0.post0\npytz==2025.2\nscikit-learn==1.7.2\nscipy==1.16.3\nsix==1.17.0\nthreadpoolctl==3.6.0\ntzdata==2025.2\nxgboost==3.1.2","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":14,"endColumn":15}}]}],"epochCounter":30},"recentSnapshot":{"entries":[{"resource":"file:///home/trang/localnsv/mAIware/ai-client.js","languageId":"javascript","originalHash":"68e531d","currentHash":"f72153c","state":0,"snapshotUri":"chat-editing-snapshot-text-model:/home/trang/localnsv/mAIware/ai-client.js?%7B%22sessionId%22%3A%2257354b3e-3103-4bae-8ae7-bc7897834d59%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-sonnet-4.5","modeId":"agent"}},{"resource":"file:///home/trang/localnsv/mAIware---AI/predict_single.py","languageId":"python","originalHash":"8dc71fd","currentHash":"2e69d5c","state":0,"snapshotUri":"chat-editing-snapshot-text-model:/home/trang/localnsv/mAIware---AI/predict_single.py?%7B%22sessionId%22%3A%2257354b3e-3103-4bae-8ae7-bc7897834d59%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-sonnet-4.5","modeId":"agent"}},{"resource":"file:///home/trang/localnsv/mAIware/script.js","languageId":"javascript","originalHash":"5d5b25f","currentHash":"6c164e7","state":0,"snapshotUri":"chat-editing-snapshot-text-model:/home/trang/localnsv/mAIware/script.js?%7B%22sessionId%22%3A%2257354b3e-3103-4bae-8ae7-bc7897834d59%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-sonnet-4.5","modeId":"agent"}},{"resource":"file:///home/trang/localnsv/mAIware---AI/requirements.txt","languageId":"pip-requirements","originalHash":"c1e576c","currentHash":"a059d30","state":0,"snapshotUri":"chat-editing-snapshot-text-model:/home/trang/localnsv/mAIware---AI/requirements.txt?%7B%22sessionId%22%3A%2257354b3e-3103-4bae-8ae7-bc7897834d59%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_cea1c3f5-681f-43b2-927b-2bd12d471bbb","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-sonnet-4.5","modeId":"agent"}}]}}